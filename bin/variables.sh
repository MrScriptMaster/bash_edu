#!/bin/bash
#
# ПЕРЕМЕННЫЕ И ПРИЕМЫ РАБОТЫ С НИМИ
# ---------------------------------
# По неформальной договоренности, в Bash локальные переменные принято именовать в нижнем
# регистре, а глобальные переменные в верхнем. Если вы пишите Bash-библиотеку, то
# рекомендуется все глобальные переменные начинать одним или двумя символами подчеркаивания.
GLOBAL_VARIABLE="global"                    # Глобальная переменная в сценарии
__LIB_GLOBAL_VARIABLE="lib_global"          # Чтобы избежать потенциального пересечения по именам, используйте нижнее подчеркивание
                                            # для библиотечных глобальных переменных
dummy() {
    local local_var="local_var"               # Локальные переменные минимально должны объявляться с квалификатором 'local'
    declare local_var_1="local_var_1"         # или 'declare'
    typeset local_var_2="local_var_2"         # или 'typeset'
    local_wrong_var="wrong_local"             # но НЕ ТАК (ОШИБКА)
    return 0
}
# Пока функция не будет вызвана, нашу неправильную локальную переменную вы не увидите.
echo "You should see nothing: ${!local*}"
dummy
# После выхода из функции, ее якобы локальная переменная 'local_wrong_var' не затерлась, то есть на лицо ошибка
# не соблюдения ограничения области видимости.
echo "You should see 'local_wrong_var': ${!local*}. It is huge mistake."
unset -v local_wrong_var    # Но ее можно удалить вручную.
echo "You should see nothing: ${!local*}. It's fine."
# Примечание:
#    Обратите внимание, что у операций
#       local_wrong_var=
#       unset -v local_wrong_var
#    одинаковый конечный результат. Однако, если вы хотите сбросить переменную (т.е. освободить имя), то всегда
#    делайте это через unset, так как интерпретатор может выполнять внутренние сопутствующие действия.
#
# Несколько переменных можно объявить одной строкой
VARIABLE_1="value1" VARIABLE_2="value2" VARIABLE_3="value3"      # Следует делать так с умом, так как это понижает читаемость сценария и ПЛОХО ПЕРЕНОСИМО
declare VARIABLE_4="value4" VARIABLE_5="value5"
# Строго говоря, использование неинициализованных переменных является ошибкой, так как не все команды корректно работают с NULL-значением.
VARIABLE_6=        # НЕ РЕКОМЕНДУЕТСЯ не инициализировать переменные. Следует хотя бы присваивать им пустые строки.
for value in ${!VARIABLE_*}; do
    eval echo "Value of the '$'$value=\$$value"
done
#
# ИНСТРУКЦИИ DECLARE И TYPESET
# ----------------------------
# В Bash все переменные хранят строковый тип. Иногда это приводит к ошибкам, когда требуется одни переменные интерпретировать
# всегда как строки, а другие всегда как числа. Ключевые слова declare и typeset позволяют наложить ограничения на использование
# переменной. Их применение НЕ ПЕРЕНОСИМО, но если вы не используете не стандартные оболочки (отличные от KSH/BASH/ZSH), то
# их применение РЕКОМЕНДОВАНО. РЕКОМЕНДУЕТСЯ использовать эти слова в сценариях прикладного назначения, но НИ В КОЕМ СЛУЧАЕ не в сценариях,
# участвующих в загрузке системы.
#
# Ключевые слова declare и typeset полностью идентичны друг другу. Исторически typeset появилось раньше в оболочке KSH, а declare в BASH (намного позже), т.е.
# typeset более переносимо. Тем не менее, если вы используете еще к этому readonly (башизм), то рекомендуется использовать именно вариант
# declare, как более информативный.
# Ключевые слова declare и typeset внутри функции сужают область видимости как local.
unset -f dummy
readonly DGLOBAL_CONSTANT="global_const"             # Только в BASH-совместимых оболочках. Ограничение только на чтение.
declare -r DGLOBAL_CONSTANT_1=$DGLOBAL_CONSTANT      # Полностью эквивалентно предыдущему примеру.
declare -i DGLOBAL_NUMBER=123                        # Мы разрешаем хранить только числа. Любое не число интерпретируется как 0.
declare -ri DGLOBAL_NUMBER_CONSTANT=456              # Переменная кроме числового типа является еще константой.
declare -a DGLOBAL_ARRAY=('one' 'two' 'three')       # Переменная должна интерпретироваться как массив.
declare -x DGLOBAL_EXPORT='exported_var'             # Глобальная переменная, экспортированная в область переменных окружения.
for value in ${!DGLOBAL_*}; do
    eval echo "Value of the '$'$value=\"\$${value[@]}\""
done
#
# ВСТРОЕННЫЕ ПЕРЕМЕННЫЕ
# ---------------------
# 1. Информация об оболочке (ТОЛЬКО BASH-совместимые оболочки)
for index in {0..5}; do
    echo "BASH_VERSINFO[$index]=${BASH_VERSINFO[$index]}"
done
# Версия BASH одной строкой
echo "$BASH_VERSION"
# 2. Содержимое вершины стека каталогов, используемого командами pushd и popd.
echo "$DIRSTACK"
# 3. Редактор, вызываемый по умолчанию (может быть не задан)
[ ! -z "$EDITOR" ] && echo "$EDITOR"
# 4. Эффективный идентификатор пользователя (числом)
echo "$EUID"
# 5. Имя текущей функции. Если мы не внутри функции, то может хранить NULL (в большинстве реализаций) или "MAIN".
[ ! -z "$FUNCNAME" ] && echo "$FUNCNAME"
# 6. Перечень символов, которые будут игнорироваться при подстановке имен файлов (GLOBBING).
[ ! -z "$GLOBIGNORE" ] && echo "$GLOBIGNORE"
# 7. Группы, в которых состоит текущий пользователь.
echo "${GROUPS[@]}"
# 8. Домашний каталог пользователя
echo "$HOME"
# 9. Сетевое имя хоста
echo "$HOSTNAME"
# 10. Тип аппаратной архитектуры хоста
echo "$HOSTTYPE"
echo "$MACHTYPE"
# 11. От Input Field Separator. Хранит все символы, которые являются разделителями полей для некоторых встроенных команд.
echo "$IFS" | cat -vte
# 12. Задает порядок сортировки символов в операциях подстановки имен файлов или поиске по шаблону.
[ ! -z "$LC_COLLATE" ] && echo "$LC_COLLATE"
# 13. Задает кодировку символов в операциях подстановки имен файлов и поиске по шаблону.
[ ! -z "$LC_CTYPE" ] && echo "$LC_CTYPE"
# 14. Возвращает номер строки, на которой в данный момент переменная раскрывается.
echo "$LINENO"
# 15. Возвращает предпоследний рабочий каталог.
echo "$OLDPWD"
# 16. Все каталоги, в которых будут искаться исполняемые файлы для команд.
echo "$PATH"
# 17. Код возврата конвейера. НЕ ПУТАТЬ с $?
echo "$PIPESTATUS"
# 18. Строка приглашения
echo "$PS1"    # Приглашение командной оболочки
echo "$PS2"    # Дополнительный ввод
echo "$PS3"    # Приглашение команды select
echo "$PS4"    # Приглашение 4-го уровня, когда сценарий вызывается с флагом -x
# 19. Текущий рабочий каталог.
echo "$PWD"
# 20. В эту переменную записывается ввод команды read и select, если не указана другая.
echo "$REPLY"
# 21. Только в BASH-совместимых оболочках. Выводит время работы сценария в секундах.
echo "$SECONDS"
# 22. Список всех допустимых опций для интерпретатора данной оболочки.
echo "$SHELLOPTS"
# 23. Выводит уровень вложенности оболочки. Если это сценарий, то отсчет начнется с 2 и дальше.
echo "$SHLVL"
# 24. Время ожидания ввода на уровне приглашения PS1. К сожалению, в сценариях эта переменная бесполезна: используйте другие способы.
echo "$TMOUT"
# 25. Идентификатор текущего пользователя
echo "$UID"
# 26. Путь к исполняемому файлу сценария
echo "${BASH_SOURCE}"
#
# СПЕЦИАЛЬНЫЕ ПЕРЕМЕННЫЕ
# ----------------------
echo "(Flags): $-"              # Все флаги, переданные командой set
echo "(Last daemon PID): $!"    # PID последнего запущенного фонового процесса
echo "(Last argument of previous command): $_"   # Последний аргумент предыдущей команды
echo "(Exit code of previous command): $?"   # Последний аргумент предыдущей команды
echo "(PID of current proccess): $$"   # Идентификатор текущего процесса
#
# ПОЗИЦИОННО-ЗАВИСИМЫЕ СПЕЦИАЛЬНЫЕ ПЕРЕМЕННЫЕ
# -------------------------------------------
# Аргументы сценария или функции
echo "$0 $1 $2 $3 $4 $5"    # Первые 6 аргументов сценария
# Кол-во аргументов, которые можно передавать, зависит от: ограничений системы (главным образом от максимального размера стека), 
# длины каждого передаваемого аргумента и текущей длины всех переменных окружения.
# Передавемые аргументы должны уместиться в буфер с минимальным размером:
echo "ARG_MAX = $(getconf ARG_MAX) B"
echo "AVERAGE = $(( $(getconf ARG_MAX)/4 - 1 )) (arguments)" 
# Тем не менее, если аргументы очень короткие, то их число должно быть не больше
BINFMTS="$(find /usr/include/ -type f -name binfmts.h)"
if [ -n "$BINFMTS" ]; then 
    MAX_ARG_STRINGS="$(grep '^#define \<MAX_ARG_STRINGS' "$BINFMTS" | cut -d' ' -f 3)"
    NUMBER="$(echo "$MAX_ARG_STRINGS" | sed -e 's:^0[xX]::' | tr '[a-f]' '[A-F]')"
    echo "MAX_ARG_STRINGS = "$(echo "ibase=16; "$NUMBER"; obase=10" | bc)""
fi
echo "ARGC=$#"    # Число позиционных параметров, переданных сценарию или функции.
echo "(one line) ARGV=$*"  # Все аргументы, переданные сценарию или функции, одной строкойю
echo "(multi line) ARGV=$@"  # Все аргументы, переданные сценарию или функции, несколькими строками.
# Интерпретация $* и $@ зависит от значения IFS.
#
# Командой set можно изменять позиционные параметры прямо в сценарии.
set -- "arg1" "arg2" "arg3"  # Примечание: символы тире говорят о том, что переменные нужно перенести в позиционные параметры.
declare -i COUNTER=0
echo "ARGC=$#"
for arg in $@; do
    echo "\$$COUNTER=$arg"
    : $(( COUNTER++ ))
done
echo "ARGV (\$*)=$*"
echo "ARGV (\$@)=$@"
#
# Для сброса позиционных параметров достаточно написать только два знака тире.
set --
echo "Parameters has been dropped"
COUNTER=0
echo "ARGC=$#"
for arg in $@; do
    echo "\$$COUNTER=$arg"
    : $(( COUNTER++ ))
done
echo "ARGV (\$*)=$*"
echo "ARGV (\$@)=$@"
