#!/bin/bash
#
# В Bash есть следующие типы циклов:
#
# * for ... in ...; do ... ; done
# * while ...; do ... ; done 
# * until ...; do ... ; done
# * select ... in; do ... ; done
#
# ЦИКЛ FOR
# --------
# Цикл for используется обычно, когда число итераций в цикле известно.
# Цикл имеет две записи:
#  - КЛАССИЧЕСКАЯ (Прим.: всегда пользуйтесь только классической записью)
#
# Вариант, когда перебираемое множество не указано. В этом случае автоматически
# подставляется $@.
for arg; do           # or    for arg in $@; do ...
	echo "$arg"
done
# Вариант с явным перебираемым множеством
for arg in alpha beta gamma {1..4}; do
	echo "$arg"
done
#
# - ИСТОРИЧЕСКАЯ (Прим.: НИКОГДА не пользуйтесь. Она не задокументирована и не переносима)
for arg; {
	echo "$arg"
}
#
for arg in {5..8}; {
	echo "$arg"
}
#
# - BASH-совместимая (оформление цикла похожее на принятое в языке C)
for (( i=0; i < 3; i++ )); do
	echo "C-style: $i"
done
# Точку с запятой можно опускать для такой записи (НО НЕ РЕКОМЕНДУЕТСЯ, так как это смущает)
for (( i=0; i < 3; i++ )) do
	echo "C-style: $i"
done
# У этой записи также есть историческая, не задокументированная форма (НИКОГДА ей не пользуйтесь, потому что не переносима)
# Тем не менее, эта запись больше всего похожа на C-style.
for (( i=0; i < 3; i++ )) {
	echo "Historical C-style $i"
}
#
# В классической записи цикл выполняется, пока не закончится множество. В BASH-совместимой
# форме цикл выполняется, пока условие, записанное после первой точки с запятой, является ИСТИНОЙ.
#
# Папример, сравните две записи
####
# for (( <INDEX> ; <CONDITION> ; <INCREMENTATION> )); do
#    <ACTIONS>
# done
####
# <INDEX>
# while <CONDITION>; do
#    <ACTIONS>
#    <INCREMENTATION>
# done
####
#
# В BASH-совместимой форме <INDEX>, <CONDITION> и <INCREMENTATION> могут быть пустыми (в том числе по отдельности), т.е.
# такое в принципе разрешено 
#    for (( ; ; )); do ...    # Бесконечный цикл
# Но для бесконечных циклов ВСЕГДА используйте while, как более понятный и переносимый вариант.
#
# Циклы for удобны при переборе массивов.
declare -a array=('I' 'II' 'III' 'IV' 'V' 'VI' 'VII' 'VIII')
# перебор в стилe foreach
for element in ${array[@]}; do
	echo "$element"
done
# перебор по индексам
for index in ${!array[@]}; do
	echo ${array[$index]}
done
# Для ассоциативных массивов в Bash 4 можно использовать
declare -A array_1=(
	[date]=$(date --rfc-3339='seconds')
	[message]="hello"
	[param_1]="1"
	[param_2]="2"
)
echo "${#array_1[@]}"
for key in "${!array_1[@]}"; do
	echo "Key: $key      Value=${array_1[$key]}"
done
#
# ЦИКЛ WHILE
# ----------
# Самая универсальная форма цикла. К циклу while может быть сведен любой цикл.
# Цикл while выполняется до тех пор, пока условие ИСТИНА.
# Примечание: ключевые слова 'true' и 'false' являются командами системы: true всегда возвращает 0, а false - 1.
# В BASH вы можете также использовать встроенную команду ':', которая также всегда возвращает 0.
while true; do	# Бесконечный цикл.
	# Делаем цикл конечным
	declare -i terminator   # Прим.: declare -i инициализирует переменную значением NULL, однако это эквивалентно 0.
	echo "while: iteration=$terminator"
	if (( $(( ++terminator )) == 3 )); then break; fi
done
# Работает аналогично, но МЕНЕЕ ПЕРЕНОСИМО
terminator=0
while :; do	# Бесконечный цикл.
	echo "while: iteration=$terminator"
	if (( $(( ++terminator )) == 3 )); then break; fi
done
#
# ЦИКЛ UNTIL
# ----------
# Похож на цикл while, но работает, пока условие ЛОЖНО. Используется очень редко, из-за того, что на
# практике позитивные проверки приходят на ум обычно раньше.
terminator=0
until false; do # Бесконечный цикл
	echo "until: iteration=$terminator"
	if (( $(( ++terminator )) == 3 )); then break; fi
done
#
terminator=0
until ! :; do
	echo "until: iteration=$terminator"
	if (( $(( ++terminator )) == 3 )); then break; fi
done
#
# ЦИКЛ SELECT
# -----------
# Похож на классический цикл for и служит для упрощения создания различных терминальных меню.
# Вы указываете переменную, в которую помещается список из возможных вариантов ввода.
# Все варианты в списке имеют свой индекс, начиная с единицы. Когда цикл вызывается, то он блокиуется
# на операции ввода до тех пор, пока пользователь не выбрет валидный вариант из списка.
# Если выбранный вариант не валиден, то цикл начинается заново, иначе он прерывается. Прервать цикл
# можно либо в его теле, либо по сигналу.
# Запросить выбранный пользователем вариант, вы можете через переменную окружения $REPLY.
select color in "red" "green" "blue"; do
	echo -n "Your choice is $REPLY - "
	if [[ -z "$color" ]]; then
		echo "<not valid input>"
	else
		echo "$color"
	fi
	case $REPLY in
		[1-3]) break ;;
		*) echo "Wrong choice. Please, try again." ;;
	esac
done
# Как и в цикле for, если не указан список вариантов, подставляется "$@". Это удобно,
# когда вызовы меню оформляются через функции.
select something; do
	[[ -z $something ]] || break
	echo "Wrong choice. Please, try again."
done
# 
# Для select тоже есть исторические формы записи. Знайте их, но НИКОГДА не пользуйтесь в новых
# сценариях.
#
# select <SELECTED> in <OPTIONS>
# {
#     <ACTIONS>
# }
#
# select <SELECTED>
# {
#    <ACTIONS>
# }
#
# УПРАВЛЕНИЕ ЦИКЛОМ
# -----------------
# Все приведенные циклы управляются двумя встроенными командами: break и continue.
#   - break безусловно прерывает исполнение цикла;
#   - continue безусловно выполняет переход в начальную точку цикла.
# Обе команды могут принимать число, которое означает применить действие к N-му
# циклу наружу относительно текущего. Если это число опускается, то предполагается
# текущий цикл, т.е. число 1.
#
# Довольно запутанный способ напечатать две пирамидки.
for k in {1..10}; do
    for i in {1..10}; do
        if [[ $k -gt 2 ]]; then break 2; fi
        for j in {1..10}; do
            if [[ $j -eq $i ]]; then echo ; continue 2; fi
            printf "$j"
        done
    done
done
#

